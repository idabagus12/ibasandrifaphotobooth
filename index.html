<!DOCTYPE html>
<html lang="id">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Ibas and Rifa's Photobooth</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Lobster&display=swap"
      rel="stylesheet"
    />

    <link
      href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap"
      rel="stylesheet"
    />

    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <div class="countdown" id="countdown"></div>
    <header>
      <h1>Ibas and Rifa's Photobooth</h1>
    </header>

    <main>
      <div class="container">
        <div class="camera-container">
          <video id="videoElement" autoplay playsinline></video>
          <div class="progress-indicator">
            <div class="progress-bar" id="photoProgress"></div>
          </div>
          <div class="controls">
            <button id="startCameraBtn">Mulai Kamera</button>
            <button id="captureBtn" class="accent-button" disabled>
              Ambil Foto
            </button>
          </div>
        </div>

        <div class="result-container">
          <div class="photo-strip" id="photoStrip">
            <div class="photo-slot" id="slot1"></div>
            <div class="photo-slot" id="slot2"></div>
            <div class="photo-slot" id="slot3"></div>
            <div class="photo-slot" id="slot4"></div>
          </div>
          <img id="finalStrip" class="final-strip" alt="Final photo strip" />
          <div class="controls">
            <button id="resetBtn" disabled>Reset</button>
            <button id="downloadBtn" class="accent-button" disabled>
              Download
            </button>
          </div>
        </div>
      </div>

      <div class="options-container">
        <div class="options-grid">
          <div>
            <h2 class="section-title">Filter Foto</h2>
            <div class="filter-options">
              <div class="filter-option active" data-filter="none">Normal</div>
              <div class="filter-option" data-filter="grayscale">B&W</div>
              <div class="filter-option" data-filter="sepia">Vintage</div>
              <div class="filter-option" data-filter="saturate">Vibrant</div>
              <div class="filter-option" data-filter="contrast">
                High Contrast
              </div>
            </div>
          </div>

          <div>
            <h2 class="section-title">Warna Font</h2>
            <div class="color-options">
              <input type="color" id="frameColor" value="#222222" />
              <button id="applyColorBtn">Terapkan</button>
            </div>
          </div>

          <div>
            <h2 class="section-title">Warna Background</h2>
            <div class="color-options">
              <input type="color" id="bgColor" value="#ffffff" />
              <button id="applyBgColorBtn">Terapkan</button>
            </div>
          </div>
        </div>
      </div>
    </main>

    <script>
      // DOM Elements
      const videoElement = document.getElementById('videoElement');
      const startCameraBtn = document.getElementById('startCameraBtn');
      const captureBtn = document.getElementById('captureBtn');
      const resetBtn = document.getElementById('resetBtn');
      const downloadBtn = document.getElementById('downloadBtn');
      const photoStrip = document.getElementById('photoStrip');
      const countdown = document.getElementById('countdown');
      const finalStrip = document.getElementById('finalStrip');
      const filterOptions = document.querySelectorAll('.filter-option');
      const frameColorPicker = document.getElementById('frameColor');
      const applyColorBtn = document.getElementById('applyColorBtn');
      const bgColorPicker = document.getElementById('bgColor');
      const applyBgColorBtn = document.getElementById('applyBgColorBtn');
      const photoProgress = document.getElementById('photoProgress');

      // Variables
      let stream;
      let currentSlot = 0;
      let capturedPhotos = [];
      let currentFilter = 'none';
      let frameColor = '#222222';
      let bgColor = '#ffffff';

      // Initialize
      function init() {
        startCameraBtn.addEventListener('click', startCamera);
        captureBtn.addEventListener('click', startCountdown);
        resetBtn.addEventListener('click', resetPhotos);
        downloadBtn.addEventListener('click', downloadComposite);
        applyColorBtn.addEventListener('click', applyFrameColor);
        applyBgColorBtn.addEventListener('click', applyBgColor);

        filterOptions.forEach((option) => {
          option.addEventListener('click', () => {
            filterOptions.forEach((opt) => opt.classList.remove('active'));
            option.classList.add('active');
            currentFilter = option.dataset.filter;
            applyFilter(videoElement, currentFilter);
          });
        });
      }

      // Start camera
      async function startCamera() {
        try {
          stream = await navigator.mediaDevices.getUserMedia({
            video: { facingMode: 'user' },
            audio: false,
          });
          videoElement.srcObject = stream;
          startCameraBtn.disabled = true;
          captureBtn.disabled = false;
        } catch (error) {
          console.error('Error accessing camera:', error);
          alert(
            'Error accessing camera. Please make sure your camera is enabled and try again.'
          );
        }
      }

      // Apply filter to video or image element
      function applyFilter(element, filter) {
        switch (filter) {
          case 'grayscale':
            element.style.filter = 'grayscale(100%)';
            break;
          case 'sepia':
            element.style.filter = 'sepia(70%)';
            break;
          case 'saturate':
            element.style.filter = 'saturate(180%)';
            break;
          case 'contrast':
            element.style.filter = 'contrast(150%)';
            break;
          default:
            element.style.filter = 'none';
        }
      }

      // Start countdown before capturing photo
      function startCountdown() {
        if (currentSlot >= 4) return;

        let count = 3;
        countdown.textContent = count;
        countdown.style.display = 'flex';

        const countInterval = setInterval(() => {
          count--;
          if (count > 0) {
            countdown.textContent = count;
          } else {
            clearInterval(countInterval);
            countdown.style.display = 'none';
            capturePhoto();
          }
        }, 1000);
      }

      // Capture photo
      function capturePhoto() {
        if (currentSlot >= 4) return;

        const canvas = document.createElement('canvas');
        const aspectRatio = 4 / 3;
        canvas.width = videoElement.videoWidth;
        canvas.height = canvas.width / aspectRatio;
        const context = canvas.getContext('2d');

        // Balik gambar secara horizontal
        context.translate(canvas.width, 0);
        context.scale(-1, 1);

        // Hitung cropping untuk menjaga aspek rasio
        const videoAspect = videoElement.videoWidth / videoElement.videoHeight;
        let sx = 0,
          sy = 0,
          sw = videoElement.videoWidth,
          sh = videoElement.videoHeight;

        if (videoAspect > aspectRatio) {
          // Video lebih lebar dari yang diperlukan, potong sisi
          sw = videoElement.videoHeight * aspectRatio;
          sx = (videoElement.videoWidth - sw) / 2;
        } else if (videoAspect < aspectRatio) {
          // Video lebih tinggi dari yang diperlukan, potong atas/bawah
          sh = videoElement.videoWidth / aspectRatio;
          sy = (videoElement.videoHeight - sh) / 2;
        }

        // Gambar ulang video ke canvas yang sudah dibalik
        context.drawImage(
          videoElement,
          sx,
          sy,
          sw,
          sh,
          0,
          0,
          canvas.width,
          canvas.height
        );

        // Kembalikan transformasi ke normal
        context.setTransform(1, 0, 0, 1, 0, 0);

        // Terapkan filter jika ada
        if (currentFilter !== 'none') {
          const imageData = context.getImageData(
            0,
            0,
            canvas.width,
            canvas.height
          );
          const data = imageData.data;

          switch (currentFilter) {
            case 'grayscale':
              for (let i = 0; i < data.length; i += 4) {
                const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
                data[i] = avg;
                data[i + 1] = avg;
                data[i + 2] = avg;
              }
              break;
            case 'sepia':
              for (let i = 0; i < data.length; i += 4) {
                const r = data[i],
                  g = data[i + 1],
                  b = data[i + 2];
                data[i] = Math.min(255, r * 0.393 + g * 0.769 + b * 0.189);
                data[i + 1] = Math.min(255, r * 0.349 + g * 0.686 + b * 0.168);
                data[i + 2] = Math.min(255, r * 0.272 + g * 0.534 + b * 0.131);
              }
              break;
            case 'saturate':
              for (let i = 0; i < data.length; i += 4) {
                const r = data[i],
                  g = data[i + 1],
                  b = data[i + 2];

                // Convert RGB to HSL
                let max = Math.max(r, g, b) / 255;
                let min = Math.min(r, g, b) / 255;
                let h,
                  s,
                  l = (max + min) / 2;

                if (max === min) {
                  h = s = 0; // achromatic
                } else {
                  let d = max - min;
                  s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

                  if (max === r / 255)
                    h = (g / 255 - b / 255) / d + (g < b ? 6 : 0);
                  else if (max === g / 255) h = (b / 255 - r / 255) / d + 2;
                  else h = (r / 255 - g / 255) / d + 4;

                  h /= 6;
                }

                // Increase saturation
                s = Math.min(1, s * 1.8);

                // Convert back to RGB
                let c, x, m;
                if (s === 0) {
                  r = g = b = l * 255;
                } else {
                  c = (1 - Math.abs(2 * l - 1)) * s;
                  x = c * (1 - Math.abs(((h * 6) % 2) - 1));
                  m = l - c / 2;

                  if (h < 1 / 6) {
                    r = (c + m) * 255;
                    g = (x + m) * 255;
                    b = m * 255;
                  } else if (h < 2 / 6) {
                    r = (x + m) * 255;
                    g = (c + m) * 255;
                    b = m * 255;
                  } else if (h < 3 / 6) {
                    r = m * 255;
                    g = (c + m) * 255;
                    b = (x + m) * 255;
                  } else if (h < 4 / 6) {
                    r = m * 255;
                    g = (x + m) * 255;
                    b = (c + m) * 255;
                  } else if (h < 5 / 6) {
                    r = (x + m) * 255;
                    g = m * 255;
                    b = (c + m) * 255;
                  } else {
                    r = (c + m) * 255;
                    g = m * 255;
                    b = (x + m) * 255;
                  }
                }

                data[i] = Math.min(255, Math.max(0, r));
                data[i + 1] = Math.min(255, Math.max(0, g));
                data[i + 2] = Math.min(255, Math.max(0, b));
              }
              break;
            case 'contrast':
              const factor = 1.5;
              for (let i = 0; i < data.length; i += 4) {
                data[i] = Math.min(
                  255,
                  Math.max(0, ((data[i] / 255 - 0.5) * factor + 0.5) * 255)
                );
                data[i + 1] = Math.min(
                  255,
                  Math.max(0, ((data[i + 1] / 255 - 0.5) * factor + 0.5) * 255)
                );
                data[i + 2] = Math.min(
                  255,
                  Math.max(0, ((data[i + 2] / 255 - 0.5) * factor + 0.5) * 255)
                );
              }
              break;
          }
          context.putImageData(imageData, 0, 0);
        }

        // Konversi canvas ke gambar
        const imgUrl = canvas.toDataURL('image/png');
        capturedPhotos[currentSlot] = imgUrl;

        // Tambahkan gambar ke slot
        const img = document.createElement('img');
        img.src = imgUrl;
        const slot = document.getElementById(`slot${currentSlot + 1}`);
        slot.innerHTML = '';
        slot.appendChild(img);

        // Perbarui progress dan slot saat ini
        currentSlot++;
        updateProgress();

        const font = new FontFace(
          'Lobster',
          'url(https://fonts.gstatic.com/s/lobster/v30/neILzCirqoswsqX9zoKmMw.woff2)'
        );

        font.load().then(() => {
          document.fonts.add(font);
          createPhotoStrip(); // Panggil ulang fungsi setelah font dimuat
        });

        if (currentSlot >= 4) {
          createPhotoStrip();
          captureBtn.disabled = true;
          resetBtn.disabled = false;
          downloadBtn.disabled = false;
        }
      }

      // Helper function for HSL to RGB conversion
      function hue2rgb(p, q, t) {
        if (t < 0) t += 1;
        if (t > 1) t -= 1;
        if (t < 1 / 6) return p + (q - p) * 6 * t;
        if (t < 1 / 2) return q;
        if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
        return p;
      }

      // Update progress bar
      function updateProgress() {
        const progress = (currentSlot / 4) * 100;
        photoProgress.style.width = `${progress}%`;
      }

      // Create final photo strip
      function createPhotoStrip() {
        const canvas = document.createElement('canvas');
        const padding = 10; // Padding antar foto
        const photoWidth = 300;
        const photoHeight = photoWidth * (3 / 4); // 4:3 aspect ratio
        const textHeight = 60; // Tinggi area teks
        const textPaddingTop = 25; // Jarak atas untuk teks "PHOTOBOOTH"
        const textSpacing = 10; // Jarak antara "PHOTOBOOTH" dan tanggal

        // Lebar canvas cukup untuk foto + padding di kiri/kanan
        const sideMargin = 20; // Sama untuk kiri, kanan, dan atas
        const canvasWidth = photoWidth + sideMargin * 2;
        const totalPhotoHeight = photoHeight * 4 + padding * 3;
        const canvasHeight =
          totalPhotoHeight + textHeight + sideMargin * 2 + textPaddingTop;

        canvas.width = canvasWidth;
        canvas.height = canvasHeight;

        const ctx = canvas.getContext('2d');

        // Gambar background utama dengan warna yang dipilih
        ctx.fillStyle = bgColor;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Gambar foto-foto
        const startX = sideMargin;
        const startY = sideMargin;
        capturedPhotos.forEach((photo, index) => {
          const img = new Image();
          img.onload = () => {
            const y = startY + index * (photoHeight + padding);
            ctx.drawImage(img, startX, y, photoWidth, photoHeight);

            // Jika ini foto terakhir, gambar teks di bawahnya
            if (index === 3) {
              ctx.fillStyle = frameColor;
              ctx.textAlign = 'center';

              // Teks PHOTOBOOTH
              ctx.font = 'bold 24px Lobster, sans-serif';
              const textY =
                canvas.height - sideMargin - textHeight + textPaddingTop;
              ctx.fillText(' Ibas and Rifa`s World ', canvas.width / 2, textY);

              // Teks tanggal dengan ukuran lebih kecil
              ctx.font = '14px Lobster, sans-serif';
              ctx.fillText(
                new Date().toLocaleDateString(),
                canvas.width / 2,
                textY + textSpacing + 14
              );

              // Tampilkan hasil akhir
              finalStrip.src = canvas.toDataURL('image/png');
              finalStrip.style.display = 'block';
              photoStrip.style.display = 'none';
            }
          };
          img.src = photo;
        });
      }

      // Reset photos
      function resetPhotos() {
        currentSlot = 0;
        capturedPhotos = [];
        for (let i = 1; i <= 4; i++) {
          document.getElementById(`slot${i}`).innerHTML = '';
        }
        photoProgress.style.width = '0%';
        finalStrip.style.display = 'none';
        photoStrip.style.display = 'flex';
        captureBtn.disabled = false;
        resetBtn.disabled = true;
        downloadBtn.disabled = true;
      }

      // Download composite
      function downloadComposite() {
        const link = document.createElement('a');
        link.download =
          'photobooth_strip_' + new Date().toISOString().slice(0, 10) + '.png';
        link.href = finalStrip.src;
        link.click();
      }

      // Apply frame color
      function applyFrameColor() {
        frameColor = frameColorPicker.value;

        // If all photos are captured, recreate photo strip with new color
        if (currentSlot >= 4) {
          createPhotoStrip();
        }
      }

      // Apply background color
      function applyBgColor() {
        bgColor = bgColorPicker.value;

        // If all photos are captured, recreate photo strip with new background color
        if (currentSlot >= 4) {
          createPhotoStrip();
        }
      }

      // Initialize on load
      window.addEventListener('load', init);
    </script>
  </body>
</html>